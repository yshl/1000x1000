(module lin_bigloo (export solve)
	(library srfi1))

(define (vector-swap! vec i j)
  (let ((vi (vector-ref vec i))
	(vj (vector-ref vec j)))
    (vector-set! vec i vj)
    (vector-set! vec j vi)))

(define (v-! vec i factor)
  (f64vector-set! vec i (-fl (f64vector-ref vec i) factor)))
(define (v*! vec i factor)
  (f64vector-set! vec i (*fl (f64vector-ref vec i) factor)))
(define (vswap! vec i j)
  (let ((tmp (f64vector-ref vec i)))
    (f64vector-set! vec i (f64vector-ref vec j))
    (f64vector-set! vec j tmp)))

(define (a@ a i j)
  (f64vector-ref (vector-ref a i) j))

(define (vlen vec)
  (cond ((f64vector? vec) (f64vector-length vec))
	((vector? vec) (vector-length vec))
	(else #f)))

(define (min-length . vecs)
  (apply min (map vlen vecs)))

(define (abs-max ai)
  (let ((n (f64vector-length ai)))
    (let loop ((ajmax 0.0) (j 0))
      (if (<fx j n)
	(loop (max ajmax (abs (f64vector-ref ai j))) (+fx j 1))
	ajmax))))

(define (scale-row factor ai from to)
  (do ((j from (+fx j 1))) ((>=fx j to))
    (v*! ai j factor)))

(define (scale-array a b)
  (let ((n (min-length a b)))
    (do ((i 0 (+fx i 1))) ((>=fx i n))
      (let* ((ai (vector-ref a i))
	     (factor (/fl 1.0 (abs-max ai))))
	(scale-row factor ai 0 n)
	(v*! b i factor)))))

(define (search-pivot a i)
  (let ((n (vector-length a)))
    (let loop ((ajimax (abs (a@ a i i))) (jmax i) (j (+fx i 1)))
      (if (<fx j n)
	(let ((aji (abs (a@ a j i))))
	  (if (>fl aji ajimax)
	    (loop aji j (+fx j 1))
	    (loop ajimax jmax (+fx j 1))))
	jmax))))

(define (pivot a b i)
  (let ((maxj (search-pivot a i)))
    (unless (= i maxj)
      (vector-swap! a i maxj)
      (vswap! b i maxj))))

(define (scale-pivot ai b i)
  (let ((n (f64vector-length ai))
	(factor (/fl 1.0 (f64vector-ref ai i))))
    (scale-row factor ai (+fx i 1) n)
    (v*! b i factor)))

(define (elim-col a b i)
  (let ((n (min-length a b))
	(ai (vector-ref a i))
	(bi (f64vector-ref b i)))
    (do ((j (+fx i 1) (+fx j 1))) ((>=fx j n))
      (let* ((aj (vector-ref a j))
	     (aji (f64vector-ref aj i)))
	(do ((k (+fx i 1) (+fx k 1))) ((>=fx k n))
	  (v-! aj k (*fl aji (f64vector-ref ai k))))
	(v-! b j (*fl aji bi))))))

(define (forward-elimination a b)
  (let ((n (vector-length a)))
    (do ((i 0 (+fx i 1))) ((>=fx i n))
      (pivot a b i)
      (scale-pivot (vector-ref a i) b i)
      (elim-col a b i))))

(define (dot-prod a b from to)
  (let loop ((sum 0.0) (i from))
    (if (<fx i to)
      (loop (+fl sum (*fl (f64vector-ref a i) (f64vector-ref b i)))
	    (+fx i 1))
      sum)))

(define (back-substitution a b)
  (let ((n (min-length a b)))
    (do ((i (-fx n 1) (-fx i 1))) ((<fx i 0))
      (v-! b i (dot-prod (vector-ref a i) b (+fx i 1) n)))))

(define (solve a b)
  (scale-array a b)
  (forward-elimination a b)
  (back-substitution a b))
